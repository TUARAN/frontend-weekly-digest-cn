> 原文：[It’s about to get a lot easier for your JavaScript to clean up after itself](https://piccalil.li/blog/its-about-to-get-a-lot-easier-for-your-javascript-to-clean-up-after-itself/)
> 翻译：TUARAN
> 欢迎关注 [前端周刊](https://github.com/TUARAN/frontend-weekly-digest-cn)，每周更新国外论坛的前端热门文章，紧跟时事，掌握前端技术动态。

# 让 JavaScript 更容易「善后」的新能力

这篇文章讨论的是一个常被忽视却又非常重要的话题：**资源清理与生命周期管理**。  
事件监听、定时器、DOM 引用、WebSocket 连接、IndexedDB 游标、外部库实例……  
如果你不在恰当的时机释放它们，Bug 可能一时半会儿看不出来，但随着时间推移会慢慢演变成内存泄漏、性能退化，甚至难以复现的诡异行为。

作者从规范和引擎演进的角度，介绍了 JavaScript 在这方面即将变得更好的一些新能力。

---

## 传统「清理模式」的问题

在没有额外语言支持的年代，我们通常这样做清理：

- 手动在组件卸载、路由切换、任务结束等时机里，调用 `removeEventListener`、`clearTimeout`、`close()` 等；  
- 自己维护一堆「资源句柄列表」，在某个统一的 `dispose()` 中一口气释放；  
- 严重依赖团队自觉和代码评审，一旦某个路径漏了，就会埋下隐患。

这些模式的问题在于：

- 很难保证所有执行路径都能走到清理分支；  
- 业务逻辑一复杂，清理代码散落在各个角落；  
- 对新同学而言，几乎没有反馈机制告诉他「这里忘记清理」。

---

## 显式资源管理与新语法的引入

文章提到，近年来规范社区在推进一种更现代的思路：**显式资源管理（Explicit Resource Management）**。  
其核心目标是，为「获取资源 → 使用资源 → 释放资源」这一模式，提供语言级别的帮助。

在设计草案中，可以看到类似以下的模式：

```js
using conn = await openDbConnection();
// 在这个 block 中使用 conn
// 离开作用域时，自动调用 conn[Symbol.dispose]() 做清理
```

或者在同步场景中：

```js
using handle = acquireHandle();
doSomething(handle);
// 作用域结束时自动清理
```

这带来的改进是：

- 把清理逻辑绑定到作用域上，而不是散落在各个手写的 `finally` 或回调里；  
- 让资源持有者通过实现特定接口（如 `Symbol.dispose`）来声明如何善后；  
- 让开发者在语法层面更自然地表达「用完即走」的意图。

---

## 对实际代码的影响

这种新能力一旦进入主流引擎和工具链，会直接改变我们写代码的方式：

- 对于需要成对出现的操作（订阅/退订、打开/关闭、注册/注销），可以更自然地用作用域管理生命周期；  
- 更容易为复杂模块设计统一的 `dispose` 逻辑，而不是暴露多个看似独立的清理函数；  
- IDE 和静态分析工具也更有机会在编译期发现「资源未被正确释放」的问题。

当然，短期内我们仍需要在项目中混用传统模式与新语法，但作者的判断是：

> **JavaScript 正在从「完全靠约定的清理」走向「语言级别的资源管理支持」，这会显著降低长期维护大型前端/Node.js 应用的成本。**

对于日常开发者而言，现在就可以开始：

- 更有意识地为模块设计清理接口；  
- 把订阅与取消、开与关当作一组 API 设计；  
- 关注运行时和规范社区关于显式资源管理的进展，为未来的语法变化留出空间。

