CSS-in-JS 原本承诺带来简单优雅，却最终带来了性能灾难。看看为什么回归原生 CSS 会让你的 Web 应用更快、更好维护。

![Featued image for: CSS-in-JS: The Great Betrayal of Frontend Sanity](https://cdn.thenewstack.io/media/2025/11/a7476e27-will-myers-_cntg_xjdga-unsplashb-1024x576.jpg)

当初我们期待的是优雅。结果却换来了运行时解析 CSS、难以辨认的类名，以及来自地狱深处的 hydration 错误。CSS-in-JS 本该把我们从全局命名空间噩梦和样式意大利面中解放出来。

但现实是，[它只是给混乱换了层镀金外皮](https://thenewstack.io/css-in-js-and-react-server-components-a-developer-guide/)——性能更差、可读性更差，而且为了完成纯 CSS 二十年前就能轻松搞定的事，还要花费更多 CPU。  
这根本算不上进化，更像是披着“进步”外衣的过度工程（over-engineering）。

## 从解放到性能枷锁

CSS-in-JS 初登场时确实惊艳。没有全局样式泄漏、不必再担心优先级大战、也不用再面对命名冲突。样式和组件可以共存于同一文件，模块化、封装、整整齐齐。

但蜜月结束得很快。大家很快意识到，在运行时生成样式[可不是个小代价](https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b)——它是一颗随时爆炸的性能地雷。本来想让样式更简单，结果却演变成前端历史上最昂贵的抽象之一。

> 将 CSS 的生成过程绑定到 JavaScript 的执行上，本质上是把展示层和逻辑层重新焊死在一起——而这正是我们发明 CSS 时想摆脱的东西。

让客户端动态计算 CSS 这个点子听上去聪明，直到你某个凌晨三点调试 SSR hydration 错误，只因为服务器和浏览器在某次 hash 时心情不同，算出了不同的类名。这种错误不像 bug，更像是开发者被营销文案背刺后的惩罚。  
CSS-in-JS 让[给按钮写个样式](https://css-tricks.com/a-thorough-analysis-of-css-in-js/)都变得像在注入依赖。为了把边框改成蓝色，你的 bundle 可能都膨胀了。

当样式的生成被放进 JavaScript 的执行流程里，我们不仅抹掉了展示与逻辑的优雅分离，还把所有东西塞进 hooks、context provider 和运行时 patch 的混乱中。

## “便利性”背后的性能税

CSS-in-JS 的拥护者常说：“性能开销可以忽略。”  
事实是：不行。

运行时样式带来的是可度量的性能损耗——从解析字符串的毫秒级时间，到重新计算布局时的内存开销。任何数字化交易场景都可能因此受到影响。

每次组件挂载时，系统都要创建、注入甚至去重 style 标签。把这个过程放大到几百个组件，渲染周期瞬间变成官僚主义流程。

> Web 的最大优势——轻量渲染，正被过度抽象一点一点蚕食。

这不是假设。性能审计不断显示：CSS-in-JS 增加了网络负担，也增加了运行时负担。  
你的 16 核开发机可能毫无感觉，但低端设备上的用户绝对会感受到。  
浏览器本来有一套成熟、优化到极致的样式系统：CSS。  
我们却用 JavaScript 重造了一个更慢、更难调、更不稳定的替代品。CSS-in-JS 没有让样式变快，只是让[调试变慢了](https://stackoverflow.com/questions/56641028/accessing-css-styles-with-javascript-is-too-slow)。

即便如此，补丁仍不断推出，试图让动态样式“更像原生”。但你永远不可能超越浏览器自己的渲染引擎。  
这就像在轮子里再造一个轮子——但它会泄漏内存，还需要每周 npm update。

## 开发体验（DX）的海市蜃楼

支持者常说 CSS-in-JS 改善了开发体验。他们说得没错——前期确实如此。样式写在组件里，作用域安全，变量触手可及。

但一旦代码库规模扩大，这种美好就立刻破灭。  
你开始追踪丢失的 props 插值，管理层层嵌套的 context provider，只因为样式无法优雅覆盖，结果逼得你要重写半棵组件树。

调试 CSS-in-JS 像在玩扫雷：点爆率极高。  
DevTools 整个变成一片乱码式选择器荒原。你点开元素看到的是类似：

```css
.css-4kq0lj {
    margin: 0 auto;
}
```

祝你好运。看看能不能从十几个相互继承的 styled component 中找出它的源头。

> 我们对“DX”的痴迷，已经变成了掩盖架构债务的烟幕。

更糟的是，CSS-in-JS 鼓励过度工程。  
原本一条简单的 media query 就能解决的事，现在却变成要导入 hook、切换 theme context。  
曾经讨论 Flexbox 怎么写的开发者，现在在讨论哪种运行时方案在 hydration 时快 2%。  
脑力负担爆表，而回报却微乎其微。

“用起来舒服”不是架构合理的证据。  
import 一下 styled-components 的那点多巴胺，很快会被性能下降和构建变慢冲淡。

便利不等于专业。  
而 CSS-in-JS 恰恰是以牺牲清晰度换来便利。

## 回归理智：一个后 CSS-in-JS 时代

好消息是，潮水正在倒退。  
很多资深 CSS-in-JS 支持者也开始承认：它无法在规模化场景中维持健康架构。  
Remix、Astro、Next.js 13 等框架开始引导开发者回归简单方案——用传统 CSS、CSS Modules 或静态提取，而不是运行时生成。

信息很明确：关注点分离依然重要。

CSS 变量、[container queries](https://www.thisdot.co/blog/css-container-queries-what-are-they) 和作用域样式的出现，让现代 CSS 已经能够原生、稳定、高性能地解决 CSS-in-JS 想解决的大部分问题。

没有运行时损耗。  
没有 hash 冲突。  
没有隐形 style 标签塞满 DOM。

只有加载即生效、行为一致的样式。

> CSS 没坏；坏的是我们作为开发者的自律。

我们不需要重造样式系统。  
我们只需要尊重当初让 Web 运作起来的边界。  
CSS 不是问题的根源，我们的做法才是。  
解决方案不是更多抽象，而是更好的理解。

前端的未来，不是把 CSS 塞进 JavaScript，而是写出能自然随 Web 演化、可维护、可扩展的样式。

回归基本功不是“倒退”，而是成熟。  
意识到我们正在用抽象层解决自己制造的问题，这不是创新——这是自欺欺人。

## 现代 CSS 已经足以解决当初的痛点

CSS-in-JS 的初衷是好的：模块化、可预测、组件化。  
但带来的却是披着“进步”外衣的复杂性。  
Web 无需运行时样式引擎，也无需加密般的类名才能现代化。

它需要的只是克制。

需要开发者承认：不是每个问题都需要一个库。

我们正迎来一个新的时代：  
简单再次成为美。  
全局样式与作用域样式可以和平共存。  
浏览器负责重体力劳动，正如它本应做的那样。

是时候停止膜拜那些拖慢我们的抽象层，开始信任我们用了几十年打磨的平台了。

准备好回归了吗？
