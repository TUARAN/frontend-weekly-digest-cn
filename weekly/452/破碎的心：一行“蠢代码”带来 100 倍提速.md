# 破碎的心：一行“蠢代码”带来 100 倍提速

- 原文：[A Broken Heart](https://allenpike.com/2026/a-broken-heart/)

遇到一个好 Bug 时，你的第一反应往往是：「[这怎么可能发生？](https://allenpike.com/2018/the-great-bug-hunt/)」

前几天我在打磨我们正在做的某个 Web 应用的仪表盘页面——你懂的，日常工作——然后发现它加载得异常慢：之前明明 1 秒就能出来，现在却要 10 秒。事情不对劲。

我下意识把锅甩给了 React。

当然，在现代 Web 应用里，性能问题的原因可以有很多：第三方 JavaScript、服务器负载过高、资源膨胀、数据库缺索引……长得能写满一整张清单。但我做 Web 做了这么多年，直觉告诉我：这是前端问题。我几乎“闻”得到。页面在加载时明显卡顿；而且即便 React 依然是如今前端世界“最不坏”的选择，它的生态里也确实充满了让代码库变得纠缠、变慢、变诡异的路径。

为了验证这个判断，我让 Claude 先分析：这个仪表盘为什么慢？把 React 相关的可疑点按严重程度排序。果不其然，它指出了一堆典型问题——不必要的重复渲染、缺少 memoization。我这才意识到我们甚至还没用上 React Compiler。于是我让 Claude 把最容易、最严重的那几处先改一遍，然后……

几乎没什么变化。

也许根本不是 React。

于是我撸起袖子，开始正儿八经地排查：

1. 服务器是不是很慢？有点慢，但并没有阻塞前端。
2. 所有浏览器都这样吗？不是，居然是 Safari 特有？
3. 那一定是第三方脚本？Intercom？不是。PostHog？也不是。
4. 好吧，来认真看一眼性能时间线。

这些年 Safari 的性能分析工具和 Chromium 的已经走上了不同路线，而且（至少在这个页面上）还有点不稳定。但它给出的画面非常清晰：页面并没有花 7 秒以上在解析 JavaScript、计算样式，或是从网络加载资源。它把一台 M1 Max 的 CPU 用掉了 94%……用在了布局（Layout）上？

![](https://allenpike.com/images/2026/safari-profile.jpg)

进一步看细节，Safari 显示有多次 Layout pass，每次都要 1600ms 以上。作为参照，这大约是“正常情况应有速度”的 100 倍。Flexbox 的布局计算确实可能慢，但不应该慢到这种程度。

## 该把东西一块块拆掉了

这时我拿出了一个“老工具”，而且在当下反而更好用了：二分法（binary search）。

做法很简单：把现象解释给一个 coding agent，然后让它反复删除那些可能导致问题的代码，看问题是否消失；一旦找到“删掉某块代码就能恢复”的分界点，再把内容逐步加回来，最终得到一个足够小的变更，从而定位根因，并找到可行的规避方案。

如果 agent 能自己观察到问题（比如能跑性能分析），速度会更快。但我手头并没有“命令行版的 Safari 性能分析工具”。即便如此，在我只用 10 分钟告诉 Claude「这次改动有没有修好」，并在每一步引导它总结我们刚刚学到的东西后，我们就找到了罪魁祸首。

一个爱心 emoji：❤️

我前不久在「发送反馈」按钮里加了这个 emoji。如果把它去掉，Safari 就能在 2ms 内完成布局；如果加回来，页面的每一次布局会变成 1600ms，而且还不止一次。

我喜欢在原型界面里用 emoji：它们很好加，而且我一直以为它比图片加载更快。对吧？一个字符而已，怎么可能比整个动态 React 应用的渲染（在 Safari 的术语里叫“Layout”）慢 100 倍？这看起来像是 Safari 的 Bug。

通常这就是那种「好了我需要一杯酒」的时刻。但当时还没到中午，所以我去又续了一杯咖啡。

## 先做一个最小复现

当你认为这是浏览器 Bug 时，你会想提交 bug。但你不能把整个项目扔给浏览器团队说：「跑一下我们生产应用，Safari 有问题。」他们需要的是最小复现（minimal repro）：一个简单的文件，打开就能触发问题。

这对提交者来说通常很痛苦：要把一个包含专有内容的大型应用“煮”成最小复现，既枯燥又费时。

但这件事现在变得容易多了：coding agent 非常擅长做最小复现。它可以一次性改大量代码，而且这项工作通常不需要太多创造力——你就是不断删除内容，只要 bug 还在，就继续删。

很快，我就得到了一份非常简单的复现样例。而当我盯着这个最小复现代码时，真正的“根因”也一眼就出来了。

在我的 Mac 上，Safari 26.2 会花 1600ms 来“Layout”下面这段 HTML：

```html
<!DOCTYPE html>
<html>
<head>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Color+Emoji" rel="stylesheet">
  <style>
    body { font-family: "Noto Color Emoji"; }
  </style>
</head>
<body>
  💔
</body>
</html>
```

罪魁祸首不是 emoji 本身，而是：Noto Color Emoji。

## 字体也可以自带颜色

传统意义上字体只是一堆轮廓：你用黑色/白色/任何你指定的颜色去渲染它。但 2008 年苹果在 iPhone OS 2.2 里推出了 [Apple Color Emoji](https://typographica.org/typeface-reviews/apple-color-emoji/)，并在 2011 年把它带到 Mac。emoji 的流行推动了「字体能自带颜色」的需求。

最早苹果的彩色 emoji 方案更像是一种 hack：在字体里塞 PNG 图片。这既不标准，也不具备分辨率无关性；离开某个尺寸范围，它看起来会非常糟。

后来出现了多套竞争性的彩色字体标准（苹果、Mozilla、Google、微软都各自有方案），并提交到了 OpenType 1.7。看上去像是“支持了就完事了”。

但事情当然没那么简单。

## COLRv1 的“SVG 回退”在 Safari 上很慢

Noto Color Emoji 是 Google Fonts 上的一套字体，它的价值是：跨平台一致的 emoji 渲染效果。我们之前把它加入项目，是为了在 Linux 上获得更好看的 emoji（我们在云端做了一些 HTML→视频的渲染，听起来很离谱，但在某些场景确实好用）。

但这套字体依赖 [COLRv1](https://developer.chrome.com/blog/colrv1-fonts)（Google 的说法是：它比位图更小，能让应用加载更快），并且会为“其他浏览器”提供 SVG 作为回退。

而这里的“其他浏览器”，恰好就是 Safari。

看起来，这个“回退到 SVG”的路径，会让 Safari 为了渲染一个字符在 Layout 上花 1600ms。

如果你想看更夸张的效果，可以试试在 iPhone 上打开 Google Fonts 的 Noto Color Emoji 展示页（截至 iOS 26.2，体验并不好）：

![](https://allenpike.com/images/2026/iphone-emoji-error.png)

## 修复与规避

我在 Slack 里提到这个问题后，Daniel Jalkut 已经在 WebKit 的 bug tracker 里[提交了 bug](https://bugs.webkit.org/show_bug.cgi?id=305636)。WebKit 团队的 Simon Fraser 也已回复：慢点似乎出在 CoreSVG 里。这个问题大概率会被修复。

在修复落地之前，一个朴素的经验是：在 Apple 平台上不要把 Noto Color Emoji 放在字体列表前面——优先列出 `Apple Color Emoji`，等 Safari 修复并且覆盖到足够多用户之后再说。

## 最后：coding agent 像电锯

还有个小秘密：这次 Claude 确实帮我把调试速度提升了一个数量级……但当初把我们引向 Noto Color Emoji 这条路的，其实也是 Claude。

我猜如果没有 coding agent，我们当时会用更“无聊”的方式解决 Linux 上的 emoji 问题（比如用 icon library），就不会踩到这个“慢 emoji”坑。

这些 coding agent 很像电锯：强大、有用，但也同样危险。

所以……就当是给 Claude 举杯吧：既是问题的起因，也是问题的解决方案。
