# 为什么在生产环境用 Bun（可能）不是最佳选择

> 原文： [Why using Bun in production (maybe) isn't the best idea](https://dev.to/wojtekmaj/why-using-bun-in-production-maybe-isnt-the-best-idea-3deb)
>
> 翻译： [樱吹雪](https://juejin.cn/user/1179091901098269)

Bun 值得肯定。它速度快、野心大，撼动了曾经一度停滞的 JavaScript 生态系统。在 Bun 展示了“一体化体验”能带来何种感受之后，激动人心的创新步伐显著加快了。曾经保守得过分的 Node.js 突然开始发力交付：原生 TypeScript 支持、核心内置 fetch、内置 watch 模式、官方测试运行器（test runner）以及 .env 支持。Bun 点燃了这把火，让整个生态系统都热络了起来。

这对所有人来说都是一件好事。但在生产环境中，美好的愿景往往会遭遇现实的混乱（熵增）。

## “包罗万象”还是“可持续发展”？

当 **Bun 1.0** 发布时，它的卖点不仅仅是“另一个运行时”。它旨在取代 Node 本身及其周围的半打工具：`npx`、`dotenv`、`cross-env`、`nodemon`、`pm2`、`ws`、`node-fetch`/`isomorphic-fetch`、`tsc`、`Babel`、`ts-node`、`tsx`。在当时，这种“大包大揽”的故事仿佛就是未来。

两年后，许多原本作为头条宣传的功能已经**落地 Node**。而 Node *没有*吸收的部分（如打包、包管理等），或许更适合留在用户空间（userland），因为在那里的专业化分工和快速迭代更为繁荣（想想 Rolldown 或 LightningCSS）。并非所有东西都应该集成到一个运行时中，因为恕我直言，没有哪个单一团队能够同时在*所有方面*都做到极致。

## 性能：它很快，但是……

Bun 发布时的光环在于速度。虽然他们对性能的执着依然存在，并继续推动着行业向前发展，但他们用来宣传 Bun 的一些图表从一开始就经不起推敲——比如在 Yarn v3 已经发布的情况下，却拿 **Yarn v1** 做对比。更糟糕的是，**两年后的今天，这些图表依然被显著地挂在官网上**。

其他的头条数据也往往缺乏背景信息。以“Bun 比 Vitest 快 5 倍”为例。这听起来很厉害，直到你意识到 Vitest 和 Jest 是故意增加开销以实现**测试隔离**（test isolation）的，这使得测试更具确定性且更易于调试。这正是 Jest 当年能够从 Mocha 手中夺回王座的部分原因。

无视这些权衡并非在提供信息，而是在误导用户。往好了说，这是信息不全；往坏了说，这就是不诚实的营销。

与此同时，生态系统的其他部分并没有停滞不前。Node、npm、pnpm、Vitest 等都在持续改进。此外，社区倡议（例如 [e18e](https://e18e.dev/)）正在推动整个生态系统的性能提升，而不仅仅是 Bun 一家。

## 可移植性与锁定：易于上手，难于脱身

Bun 附带了一些**非标准的 API**，这些 API 在第一天使用时可能感觉很棒，但它们会悄无声息地将你与 Bun 绑定在一起。使用 `bun init`、`bun test` 以及像 `Bun.file`、`Bun.serve` 和 `Bun.YAML.stringify` 这样的辅助工具确实很诱人。但如果以后出了问题想要迁移？祝你好运。

看看那个长期存在的“[支持 Vitest](https://github.com/oven-sh/bun/issues/4145)”的请求。它在 Bun 1.0 之前就已开启，至今仍未关闭。如果你想认真尝试 Bun，实际上就是被逼着去使用 **Bun 自带的测试运行器**。这看起来很方便，直到你想换回 Node 或其他运行时，却不得不面对繁琐的迁移工作。

## 版本控制与稳定性：版本号是一份契约

在宣布 `1.0` 之后，Bun 发布了数十个 `1.0.x` 版本，其中包含了新功能——而不仅仅是错误修复——试图将 1.1 版本留给那个“房间里的大象”（显而易见的大目标）——Windows 支持。

这根本不符合语义化版本控制的运作方式；它更接近那个互联网上著名的“[自豪版本号](https://pridever.org/)”笑话：

> **PROUD.DEFAULT.SHAME（自豪.默认.羞耻）**
>
> PROUD 代表你引以为豪的变更，DEFAULT 代表常规发布，SHAME 代表你希望没人注意到的修复。

如果*补丁*版本中包含了新功能，那还有什么能阻止他们在*次版本*中发布破坏性变更呢？我们不需要猜测，因为这**正是已经发生**的事情！

例如，Bun 1.1 更改了默认的 `NODE_ENV` 值，更改了条件导出的解析方式，而 1.1.26 更改了 `node:http` 中的 `idleTimeout`。

对于生产团队来说，版本号是一份契约。它们发出信号，告知何时可以安全升级，何时需要做好应对冲击的准备。如果这些信号无法被信任，升级就变成了俄罗斯轮盘赌。

与 Node 相比：如今，Node 在“当前（Current）”版本上发布速度很快，因此你可以快速尝试新功能。但它同时也拥有**久经考验、超级稳定的 LTS 版本线**（偶尔也会接收一些很酷的新东西！），这种双轨模型至关重要。你可以在前沿进行实验，但当你需要可靠性时，LTS 的节奏能恰好满足你的需求。这种平衡正是 Node 能够胜任生产环境的原因。

## 值得商榷的设计选择

**`package.json` 中的 JSONC**：注释确实好用，但让 `package.json` 不再是标准的 JSON 会破坏与所有其他工具的兼容性。这是碎片化，而不是进步。

**二进制锁文件**：Bun 最初采用了一种二进制锁文件，这使得 PR（代码合并请求）审查变得不透明——对于任何试图混入恶意代码的人来说，这简直是梦幻场景。虽然后来切换回了文本格式，但其可读性远不如 pnpm 或 Yarn。难以审计的锁文件会削弱安全文化。

**生命周期脚本**：Bun 默认不运行它们（这部分解释了它为何“安装更快”——因为做的工作更少了）。默认跳过脚本是一个极好的主意，极大地提高了生态系统的安全性，因此其他包管理器也迅速采纳了这一点。问题在于细节：Bun 维护着一份**随意的“流行包”白名单**，这些包的脚本会运行。如果你在名单上，你的 `postinstall` 就会执行——这对你来说很好（或者……对于[盗取你 npm 账号的人](https://www.aikido.dev/blog/npm-debug-and-chalk-packages-compromised)来说也很好）。如果你不在名单上，Bun 用户就需要执行额外的步骤来让你的包正常工作。这简直是“既无实际安全性也无实际便利性”的完美结合。

## “YOLO”式（随心所欲）的路线图与对邻居的漠视

Bun 给人的感觉往往是：上周 Twitter 投票谁赢了，这周就发布什么功能。

Bun 发布这些功能的速度可能令人陶醉，但也导致了越界：Bun 1.2.22 中添加了**一个凭空捏造的 `tsconfig.json` 标志** `jsxSideEffects`。试想一下：这个标志是由一个非 TypeScript 本身的项目硬塞进 TypeScript 命名空间的。如果 TS 团队以后真的想添加这个标志，混淆和破坏性变更是不可避免的。

这也让我想起了 **LightningCSS 的争议**。Bun 并没有与现有的 Rust 项目合作（该项目的作者甚至提供了 C 语言绑定并主动提供支持），而是将其**移植到了 Zig** 并维护了一份独立的副本（我之前是不是提到过关于“用户空间”和“可持续性”的问题？我想是的……）。

> https://x.com/zack_overflow/status/1822016939461337510 和 https://x.com/devongovett/status/1822020304753062281

这不是合作——这是没有互惠的重复造轮子。无论许可证是否允许，**道德规范和生态系统的信任**都很重要。

这描绘出了一个更热衷于特立独行，而不是与更广泛的社区共同建设的项目形象。我不建议将生产系统建立在这样的基础之上。

## 维护信号：问题追踪器不会撒谎

时至今日，Node——这个驱动着几乎整个地球（可能连你的牙刷都在用）的运行时——大约有 **1700 个未解决的 issue**。而 Bun，年轻得多，虽然受欢迎但采用率远低得多，却有大约 **4700** 个。原始数字永远无法告诉我们全部真相，但这种不平衡是惊人的。Node 肩负着全球的工作负载，却管理着一个精简得多的积压清单。Bun 尚在襁褓之中，却已经被淹没了。这并不能真正激发人们对生产工作负载的信心。

## 我什么时候会使用 Bun？

这不是说“永远别用 Bun”，而是说“要明智地使用”。

适用场景：

- 原型和演练场：集成后的开发体验能让你加速开发。
- 单一用途的 CLI 或脚本：在这些场景下，可移植性不那么关键。
- 性能重于一切的项目。

如果你采用它，请设置护栏：

- 坚守**标准**；隔离 Bun 特有的功能。
- 优先选择**可移植的工具**。
- **锁定版本**，仔细阅读更新日志，并像测试数据库迁移一样测试升级。

## Bun 怎样做才能赢得生产环境的一席之地

- 将**语义化版本视为契约**；新功能放在次版本（minors），破坏性变更放在主版本（majors）。
- 建立**清晰的 LTS 和发布时间表**，以便团队知道采用什么是安全的。
- 让**基准测试诚实**：同类相比，解释权衡。
- 优先**合作而非重复造轮子**：向上游贡献，公开协调。
- 以**深思熟虑、顾及生态系统**的流程来发布新功能。

## 总结

生产环境依赖于**可持续性、可预测性和信任**。目前，Bun 的设计选择、版本控制和营销削弱了这些基础。如果你看重这些，那么今天在基于 Bun 构建之前请三思。

但别误会我的意思：Bun 仅仅因为存在就让生态系统变得更好了。它提醒了所有人极致的开发体验（DX）是什么感觉，并刺激 Node 交付了期待已久的功能。而且它还在继续这样做！我对此真心表示感谢。
