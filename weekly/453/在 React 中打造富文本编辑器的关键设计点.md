> 原文：[Building a Rich Text Editor in React](https://puckeditor.com/blog/building-a-rich-text-editor-in-react)
> 翻译：TUARAN
> 欢迎关注 [前端周刊](https://github.com/TUARAN/frontend-weekly-digest-cn)，每周更新国外论坛的前端热门文章，紧跟时事，掌握前端技术动态。

# 在 React 中打造富文本编辑器的关键设计点

富文本编辑器看起来只是「一个能加粗/斜体/插入图片的输入框」，  
但真正从零在 React 中实现时，你很快会发现它远比普通表单控件复杂得多。

这篇文章基于作者构建 Puck Editor 的经验，总结了在 React 里设计富文本编辑器时需要注意的几个关键点：**数据模型、选区管理、渲染架构与可扩展性**。

---

## 一、用什么数据结构来描述文档？

作者首先讨论了「**文档数据模型**」的问题：

- 纯 HTML 字符串虽然直观，但在做撤销/重做、块级操作或协作编辑时非常笨重；  
- 更推荐使用一种结构化的「节点树」模型，例如：

```ts
type Node =
  | { type: 'paragraph'; children: Node[] }
  | { type: 'heading'; level: 1 | 2 | 3; children: Node[] }
  | { type: 'text'; text: string; bold?: boolean; italic?: boolean }
  | { type: 'list'; ordered: boolean; children: Node[] }
  // ...
```

优点是：

- 更容易在逻辑层面做块级操作（比如整段移动、列表缩进）；  
- 可以精确控制哪些节点允许嵌套在一起；  
- 序列化/反序列化到 HTML、Markdown 或 JSON 变得更可控。

---

## 二、选区（Selection）管理是核心难题

在富文本编辑器里，**选区状态几乎是最复杂的一块**：

- 用户的光标可能位于文本节点中间、两个块级节点之间，甚至跨越多个节点；  
- 每次按键、鼠标操作、快捷键都可能改变选区；  
- 工具栏按钮（加粗、列表、引用等）需要基于当前选区判断状态。

文章强调的几个实践点：

- 不要完全依赖浏览器原生的 `contenteditable` 行为，而是为选区建立自己的抽象；  
- 在 React 状态中只存「语义化」的选区（例如「第 N 段第 M 个字符到第 P 段第 Q 个字符」），  
  再映射到 DOM 上；
- 通过自定义 hook 或独立模块封装选区管理，避免它的复杂度污染整个组件树。

---

## 三、渲染架构：不要让编辑器变成「巨型组件」

作者建议把编辑器拆成几层：

- **内容视图层**：负责根据文档节点树渲染出对应的 React 元素；  
- **输入控制层**：监听键盘/鼠标事件，翻译成对文档模型的操作（插入、删除、包裹、拆分等）；  
- **工具栏与插件层**：基于当前选区和文档状态，渲染出按钮、菜单、气泡工具条等。

这样做的好处是：

- 生命周期更清晰：文档更新 → 触发视图重渲染；  
- 渐进式扩展更容易：新增一个「高亮」或「代码块」插件，只需扩展节点类型 + 渲染逻辑，而不必改动整个编辑器核心。

---

## 四、可扩展性与插件系统

一个实用的富文本编辑器，往往需要：

- 插入图片、视频、代码块、引用卡片等自定义块；  
- 针对不同业务定制格式限制和快捷键；  
- 与外部数据源（如 CMS、协作服务）集成。

作者建议在设计之初就考虑：

- 为节点类型、按键映射、命令（Command）等预留扩展点；  
- 用统一的「命令总线」来调度操作，而不是在各处散落 `setState`；  
- 为插件定义清晰的生命周期钩子（初始化、渲染、销毁等）。

---

## 五、小结：把富文本编辑器当作一个「小型文档系统」

文章最后总结道：

> 如果把富文本编辑器当成「一个大输入框」，实现一定会越来越难维护；  
> 如果一开始就把它当作「一个小型文档系统」，用数据模型 + 状态机的方式思考，它反而会变得更可控。

在 React 里打造一个生产可用的富文本编辑器，并不是一蹴而就的事情，  
但只要在数据模型、选区管理、渲染架构和可扩展性上做了合理设计，就可以在不牺牲 DX 的前提下，支撑起相当复杂的内容编辑体验。

