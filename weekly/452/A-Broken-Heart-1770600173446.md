# 破碎的心

破碎的心

或者：一行“蠢代码”带来 100 倍提速。

2026 年 1 月 31 日 •
阅读约 6 分钟

当你遇到一个好 Bug 时，第一反应往往是：“[这怎么可能发生？](https://allenpike.com/2018/the-great-bug-hunt/)”

前几天，我在打磨我们正在做的某个 Web 应用的仪表盘页面——你懂的，日常工作——然后发现它加载得*异常*慢。之前明明 1 秒就能出来，现在却要 10 秒。事情不对劲。

于是我下意识把锅甩给了 React。

当然，在现代 Web 应用里，性能问题的原因可能很多：第三方 JavaScript、服务器负载过高、资源膨胀、数据库缺索引……长得能写满一整张清单。但我做 Web 做了这么多年，直觉告诉我：这就是前端的问题。我几乎“闻”得到。页面在加载时明显卡顿。并且尽管 React 依然是当下 Web 前端“最不坏”的选择，它的生态里也确实充满了各种让代码库变得纠缠、变慢、变诡异的路径。

为了验证这个判断，我跟 Claude[1](https://allenpike.com/2026/a-broken-heart/#fn:1) 说：仪表盘加载很慢，肯定有一些 React 方面的问题，请分析并按严重程度排序。果不其然，Claude 找到了一堆 React 的“可疑点”——不必要的重复渲染、缺少 memoization。我才发现我们还没用上 React Compiler。于是我让 Claude 先把最容易、最严重的那几处 React 问题改一遍，然后……

几乎没什么变化？也许根本不是 React。

于是我撸起袖子，开始正儿八经地排查。

- 服务器是不是很慢？有点慢，但并没有阻塞前端。
- 所有浏览器都这样吗？不是，居然是 Safari 特有？
- 那一定是第三方脚本？Intercom？不是。PostHog？也不是。
- 好吧，来认真看一眼性能时间线。

这些年 Safari 的性能分析工具和 Chromium 的已经走上了不同路线，而且（至少在这个页面上）变得有点不稳定。但它给出的画面很清晰：页面并没有花 7 秒以上在解析 JavaScript、计算样式，或是从网络加载资源。它把一台 M1 Max 的 CPU 用掉了 94%……用在了布局（Layout）上？

![](https://allenpike.com/images/2026/safari-profile.jpg)