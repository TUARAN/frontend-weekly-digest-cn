> 原文：[A complete guide to React performance optimization](https://blog.logrocket.com/a-complete-guide-to-react-performance-optimization/)
> 翻译：TUARAN
> 欢迎关注 [前端周刊](https://github.com/TUARAN/frontend-weekly-digest-cn)，每周更新国外论坛的前端热门文章，紧跟时事，掌握前端技术动态。

# React 性能优化完全指南（LogRocket 解读版）

性能问题在小 Demo 里很难暴露，一旦业务复杂度上来、组件树加深、数据量增大，React 应用的各种「卡顿」「掉帧」「无谓重渲染」就会集中出现。  
这篇来自 LogRocket 的长文，系统性梳理了 **React 性能优化的几个关键维度**，并给出了针对性的实践建议。

---

## 一、识别问题：从「感觉慢」到量化指标

文章首先强调：优化之前，必须先搞清楚「**慢**」到底体现在哪儿。

可以从几个层面入手：

- **用户感知层**：首屏时间、交互延迟、滚动是否流畅、动画是否掉帧等；  
- **浏览器指标层**：如 LCP、FID、CLS、TTI 等核心 Web 指标；  
- **React 视角**：组件重渲染频率、渲染耗时、`useEffect`/`useMemo` 等 Hook 的调用情况。

借助 React DevTools Profiler、浏览器 Performance 面板、以及监控平台的数据，可以把「感觉慢」具体化，避免盲目微调。

---

## 二、减少不必要的渲染

最常见的一类问题是：组件在不需要更新时仍然频繁重渲染。

文章列出了一些常见策略：

- **拆分组件，控制重渲染粒度**：避免单个「巨型组件」负责过多 UI；  
- **使用 `React.memo` 和 `useMemo` / `useCallback`**：在合适的地方缓存计算结果和回调，前提是依赖关系清晰、不可变数据习惯良好；  
- **避免在渲染期间创建新的对象/函数**，比如在 JSX 中直接写 `onClick={() => ...}` 时要有意识地考虑其影响。

作者也提醒：  
**不要在不了解依赖结构的情况下到处乱加 `memo`/`useMemo`**，那只会把代码变得更难读，而对性能帮助有限。

---

## 三、合理利用并发特性与调度能力

在支持 React 18 并发特性的环境下，文章建议：

- 使用 `useTransition` 把「不紧急的更新」标记为可延后，让用户输入和关键交互优先完成；  
- 在路由切换或大块 UI 更新时，利用 Suspense 与流式渲染（Streaming）改善感知速度；  
- 避免在一个事件回调中触发多处昂贵计算，尽量合并或延迟到闲时（`requestIdleCallback` 等）。

这些手段并不会减少绝对工作量，但可以**显著改善用户对「卡顿」的主观感受**。

---

## 四、列表与表格：虚拟化与窗口化

长列表和数据密集型表格是 React 性能问题的高发地带。

文章建议：

- 对超过一定长度的列表几乎应当默认采用虚拟化（如 react-window、react-virtualized 等）；  
- 在表格场景中避免一次性渲染整页所有复杂单元格，优先渲染当前视口内的行列；  
- 注意滚动同步、行高不一致等虚拟化带来的 UX 细节问题。

虚拟化的核心思想是：**只渲染用户当前看得到的内容**，让 UI 和 CPU 都轻松一些。

---

## 五、静态资源与构建层面的优化

除了 React 本身，文章也覆盖了构建与静态资源层面的常见优化：

- 按路由与功能模块做代码拆分（Code Splitting），避免首屏加载整个应用；  
- 懒加载次要组件与第三方库，必要时配合 Skeleton 或 Suspense 占位；  
- 使用现代打包工具与压缩选项，减小 JS/CSS 体积；  
- 对图片、字体等资源做格式与加载策略优化。

这些措施往往对「首屏体验」和「弱网环境」尤其关键。

---

## 六、建立持续的性能治理机制

最后，作者强调性能优化不应该是一次性项目，而应当成为**工程实践的一部分**：

- 在 CI 中加入 bundle 体积守卫与基准测试；  
- 对关键页面指标设定阈值，一旦恶化就报警；  
- 在 Code Review 中有意识地讨论渲染路径与依赖关系，而不是只关注业务逻辑正确性。

一句话总结这篇指南的观点：  
**React 性能优化不是「某一个技巧」，而是一整套从监控、架构到编码习惯的综合实践。**  
只要你从「量化问题 → 减少无谓渲染 → 利用并发特性 → 优化列表与资源 → 持续治理」这条路径去推进，大多数看似棘手的性能问题都能逐步被拆解和解决。

